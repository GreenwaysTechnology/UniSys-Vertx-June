                                       Vert.x


What is Vert.X?

 Vert.x is a tool-kit to build
       functional style,
       non blocking or async,
       poly glot,
       Event driven,
       Reactive, 
            Distributed Application(MicroService) on 
                       JVM

Non Blocking and Async Programming:

Concurrency:
  Doing many thing, at the same time
Multi threading


Runtime:

  Program which is abstraction for applications 
  Program which is between the os and application.

Every application must have runtime which is running on computers
EG:
 jvm

Program Types:

1. active program: The program in Main Memory.
    ->Process : Program in exuction
 any program, in main memory must have , structure : process structure.
Any runtime will become process
 java -JVM-Process--->

Mostly all process are c programs.

2.passive program ; program which is not in main memory/ which is not accessed by cpu.


Heap:
  The ds for allocating dynamic memory .

Stack:
  The ds for  allocating dynamic memory.

Program data;

 it is ds for passive programs of running application.


What is Object?

The term object refers "memory representation of variables and methods in side heap of  
a process" : collective memory.

since memory representation , will have a structure.

passive code     ----->Active code
class Employee {
  state:variables
  methods
  public void calculate(){
  	//biz logic
  }
 
} ---->new Employee()---->

What is the structure of object?

state
vtable

why vtable?
 vtable will have only reference of methods passivly.
 because of memory management.


****************************************************************************************

Stack frame : single execution point of   a method.

Can i run multi stack frame at the same time?
 Generally no!
But yes!

someref.somemethod()---push into stack----frame is created---running..

someref.somemethod1()---push into stack----frame is created---running..

thread of execution / "thread" : 

  method of execution - single stack frame


Process Level Multi threading:

1.Process is responsible for creating and managing life cycles of frames(threads).

This is the architecture we have been using for long time.

This  architecture is called Process level Concurrency

******************************************************************************************

is there any problems with process level concurrency/multithreading?



Use case of network computing?

Java Networking and concurrency (Servlet)

 Servlet is program which has methods -GET,POST =>DOGET,DOPOST.
  Servlet is exucted on jvm(Tomcat)

Traditional web work flow:

			       JVM
				|
client---http--req1-------WebServer(Tomcat)----create a thread(get)---frame(thread)
client---http--req1-------WebServer(Tomcat)----create a thread(get)---frame(thread)
client---http--req1-------WebServer(Tomcat)----create a thread(get)---frame(thread)
client---http--req1-------WebServer(Tomcat)----create a thread(get)---frame(thread)   
client---http--req1-------WebServer(Tomcat)----create a thread(get)---frame(thread)



Evils of "Process level multi threading".

1.Blocking: use case , i want to read file and return that file to users.


client---http--req1-------WebServer(Tomcat)----create a thread()---frame(thread) --
                                                                            
                                                                       to read disk file

While reading disk file, the thread is blocked until file content is ready.
While thread is blocked, resources are going to be waste, 

2.dead lock may happen

3.starativation

4.reace conditions.

         since tomcat is managing all thread life cycles, problems starts.

*********************************************************************************************


What is solution?

 isloate process level threading.
 Dont ask process to create multi threading.

                                   
                                 "Worker thread Model" (OS Kernal Threads). 
					 |
				   Non Blocking
					 |
				      Async


The process(Runtime) never creates any threads,handles thread biz logic rather than 
process will delegate to the OS , to perform

We are going to offload the jobs from process level to os level : Non blocking archiecture.



Java and Non blocking Programming:

 Does java support non blocking(worker-thread) model?
 Does jvm supports non blocking,evented concurrency?

No!

Yes from Java 7 called "Dolphin".

Dolphin introduced experimental model for building fast disk io, called "NIO"
  NONBlocking IO. But not based on  worker thread model.

That was beginning

  due to low support from the java, only disk io was implemented: nio

later it was improved to support read and write using nio for TCP/IP . but it is still not
not "Worker thread Model".

...............................................................................................
                                   Reactor Design Pattern
.............................................................................................

                All non blocking architectures(worker-thread( are designed with  
                         "Reactor Design pattern" Pattern.



Reactor design pattern implementations:

1.nodejs
2.Vertx
3.Project Reactor (used in springWebFlux)
4.nginx
etc.......

Reactor design pattern in java:
..............................

NETTY : First Non blocking and async architecture for jvm.

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns

		       Netty
		         |
          	      nettycore
			 |
			nio
			 |
		        jvm

Netty project provides:
1.nio only for disk io but netty provided more io like
   tcp/ip,sockets,udp,http
  non blocking  
    netty uses "Reactor Model" internaly



Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library



 		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm
*********************************************************************************************



                                    Vertx


Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM. initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.


			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM



Objective of VertX:
   
    100% non blocking applications on jvm.



NonBlocking IO Apis

                NonBlocking IO Application -VertApplication
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM



vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
		|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				 |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM
**********************************************************************************************

Event driven Programming;
........................
Vertx is powered by non blocking with help of "Built in Event Mechnism" Called "Event Bus".
  -Application events

Dont call us,we will call you ----- Event Driven programming



Req : to read database records

  Client----req -----Vertx---|---delegate db operations--db

					db operations done
					<--inform vertx 
*******************************************************************************************

Vertx Tech Stack
  Build async,non blocking Apps

Spring is collection of projects called modules
  like core,data,mvc,integration,microservice.............

Like Spring Vertx is also collection projects

Vertx-core
vertx-web
Vertx-Data
Vertx-Reactive Extension
Vertx-Microservices
Vertx-Messaging
Vertx-Security
Vertx-Integration
Vertx-Devops Engineering
Vertx-Testing
Vertx-Clusters
Vertx-Services
Vertx-Cloud

******************************************************************************************

Vertx-Core:

Writing TCP clients and servers
Writing HTTP clients and servers including support for WebSockets
The Event bus
Shared data - local maps and clustered distributed maps
Periodic and delayed actions
Deploying and undeploying Verticles
Datagram Sockets
DNS client
File system access
High availability
Native transports
Clustering   
*******************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////


Does Vertx 100% NonBlocking Platform?
  Yes!, some of the API in Vertx is blocking  , particullary fs apis.

////////////////////////////////////////////////////////////////////////////////////////////

Vertx Application setup /Project Setup:
.......................................

ways :

1.maven
2.Gradle

1.plain maven project, add vertx depedencies,You can use template entry method provided by
vertx .

2.Vertx Starter project

3.Vertx maven cli project

********************************************************************************************

In terminal window

Run :

Way 1: Using maven plugin :

>mvn package exec:java

open browser

http://localhost:8888

Way 2: fat jar

java -jar target/vertx-start-project-1.0-SNAPSHOT-fat.jar


Way 3 : vertx cli tool

no need to compile,
no need .class files
only source code 

C:\session\UniSys-Vertx\unisysverxdemo\src\main\java\com\unisys\vertx>vertx run MainVerticle.java


Way 4 : via Runner utility class : looks like main methods


Have Runner class

package com.unisys.vertx;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

public class MainVerticleRunnerDemo extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(MainVerticleRunnerDemo.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Hello Vertx!!!");
  }
}
******************************************************************************************

Vertx Core Concepts:
....................

What is vertx application?

 Vertx is collection of objects.

Vertx Objects
1.Verticle
2.Vertx 

Vertx is Core  and Container object , which contains other objects ==== Spring Container.

How to create vertx object?

vertx offers only high level apis mostly through interfaces, implementations classes we cant see.

how to create vertx instance?

ways

1.using Vertx factory api

public class HelloWorldVertx {
  public static void main(String[] args) {
    //Create Vertx Instance
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx.toString());
  }

2.Via  class called AbstractVerticle

A verticle is a piece of code that can be "deployed" by Vert.x.
  -deployment : make avaialble on Vertx runtime.
 Verticle is Object , can do lot of things which is deployment on Vertx Instance

Use of verticles with Vert.x is entirely optional, but if you use them they provide an actor-like deployment and concurrency model, out of the box

The verticles communicate with each other by sending messages over the EventBus.

******************************************************************************************

if you want to create your own verticles, then you have to inherit AbstractVerticle

if you inherit AbstractVertcle, vertx reference is availble automatically,you need not use
factory method.

Abstract verticle provides life cycle methods

start
  - is called once , you deploy the verticle on vertx
stop
 - is called once , you undeploy the verticle from vertx



package com.unisys.vertx;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import io.vertx.example.util.Runner;

//separate Verticle
class HelloWorldVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("HelloWorld Verticle is ready");
    System.out.println(vertx.toString());
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("Hello World is stoped");
  }
}

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Greeter Verticle is ready");
    System.out.println(vertx.toString());
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("Hello World is stoped");
  }
}

public class HelloWorldVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    //Vertx vertx = Vertx.vertx();
    //vertx.deployVerticle(new HelloWorldVerticle());
    Runner.runExample(HelloWorldVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new HelloWorldVerticle());
    vertx.deployVerticle(new GreeterVerticle());
  }
}
********************************************************************************************
Vertx Handlers - Event Handlers:
................................

Vertx Event Handlers can be in written in two ways

1.Future && Promise Pattern
2.Reactive Pattern - RxJava2

if you come from java script && node.js background,you know the concept called "Callback
function" - callback function is other wise called as "listener function" and "handler function".

1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop starts processing.


The result of async opertion could be either success or failure

*********************************************************************************************

Future Interface 
				AsyncResult       Handler
				-------------------------
					   |
				         Future


CallBack programming : without async implementation:
...................................................

Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation
 Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate
 inside this api.
    

Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> setHandler(Handler<AsyncResult<T>> handler)
3.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
4.onSuccess
5.onFailure


  AsyncResult interface apis

   -result() - get the success result sent by Future
   -cause()   -get the failure result sent by Future
   -succeed() -test whether it was success or failure
   -failed()  -test whether it was failure or success


package com.unisys.vertx.handlers.future;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.example.util.Runner;

//Future Demo :
class BasicFutureVerticle extends AbstractVerticle {

  //various way of sending success and failure response

  //way 1 : sending empty  success response
  public Future<Void> getEmptyFuture() {
    //Create Future Object
    Future future = Future.future();
    //send empty response
    future.complete();
    //future
    return future;
  }

  //Sending Response , Response type could be any thing from primitive to Objects,lists,arrays,json
  public Future<String> getDataFuture() {
    //Create Future Object
    Future future = Future.future();
    //declare fake response
    String message = "Hello,How are you!,I am coming from Future";
    future.complete(message);
    //future
    return future;
  }

  //Sending failure Response :  String message /Throwable Instance
  public Future<String> getErrorMessage() {
    //Create Future Object
    Future future = Future.future();
    //declare fake response
    String errorMessage = "Sorry,Something went Wrong!!!";
    future.fail(errorMessage);
    //future
    return future;
  }

  //Success and failure based biz logic

  public Future<String> auth(String userName, String password) {
    //Create Future Object
    Future future = Future.future();
    //biz logic
    if (userName.equals("admin") && password.equals("admin")) {
      future.complete("Login Success!!!");
    } else {
      future.fail("Login failed!!!!");
    }

    //future
    return future;
  }


  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Future Verticle is ready!!");
    Future future = null;

    //grab empty response :Handlers api
    future = getEmptyFuture();
    if (future.succeeded()) {
      System.out.println("Future is success");
    } else {
      System.out.println("Future is failed!");
    }
    //Grab data response : Handlers api
    future = getDataFuture();
    //old style
    future.setHandler(new Handler<AsyncResult>() {
      @Override
      public void handle(AsyncResult asyncResult) {
        //test success or failure
        if (asyncResult.succeeded()) {
          //grab result
          System.out.println(asyncResult.result());
        } else {
          System.out.println(asyncResult.cause());
        }

      }
    });
    ////lambda + setHandler / onComplete + fluent pattern
    getDataFuture().setHandler(asyncResult -> {
      if (asyncResult.succeeded()) {
        //grab result
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    getDataFuture().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        //grab result
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    //Failure Resonse
    getErrorMessage().onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause().getMessage());
      } else {

      }
    });

    //biz logic
    auth("admin", "admin").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
    auth("foo", "admin").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
    //only success
    //getDataFuture().onSuccess(result-> System.out.println(result));
    getDataFuture().onSuccess(System.out::println);
    getErrorMessage().onFailure(System.out::println);

  }
}


public class BasicHanldersUsingFuture extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BasicHanldersUsingFuture.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new BasicFutureVerticle());
  }
}
**********************************************************************************************
Promise:

Promise is async abstraction largly promoted by javascript community.
Dont Compare js javascript with Vertx Promise.

Promise is semantically meaningfull abstraction for handling asyn results.

Many times developers confuse with java Fututre and Vertx Future.

Promises can't be processed directly with onComplete/setHandler/OnSuccecc/onFailure apis

if you want process, you have to convert "Promise to Future" again.

promise conversion can be done when you process or promise conversion can be before process.


Way 1 : return promise and convert future later

  public Promise<Void> getEmptyPromise() {
    //Create Promise Object
    Promise promise = Promise.promise();
    //send empty response
    promise.complete();
    //future
    return promise;
  }

inside another api
 boolean result = getEmptyPromise().future().succeeded();
    if (result) {
      System.out.println("Promise success!!!");
    }


Way 2: return promise and convert future in the api itself


public Future<Void> getEmptyPromise() {
    //Create Promise Object
    Promise promise = Promise.promise();
    //send empty response
    promise.complete();
    //future
    return promise.future();
  }

boolean result = getEmptyPromise().succeeded();
      if (result) {
        System.out.println("Promise success!!!");
      }


Code:
package com.unisys.vertx.handlers.promise;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class PromiseVerticle extends AbstractVerticle {

  // //way 1 : sending empty  success response
//  public Promise<Void> getEmptyPromise() {
//    //Create Promise Object
//    Promise promise = Promise.promise();
//    //send empty response
//    promise.complete();
//    //future
//    return promise;
//  }

  public Future<Void> getEmptyPromise() {
    //Create Promise Object
    Promise promise = Promise.promise();
    //send empty response
    promise.complete();
    //future
    return promise.future();
  }

  //Sending Response , Response type could be any thing from primitive to Objects,lists,arrays,json
  public Future<String> getDataPromise() {
    //Create Promise Object
    Promise promise = Promise.promise();
    //declare fake response
    String message = "Hello,How are you!,I am coming from Future";
    promise.complete(message);
    //future
    return promise.future();
  }

  public Future<String> auth(String userName, String password) {
    //Create Promise Object
    Promise promise = Promise.promise();
    //biz logic
    if (userName.equals("admin") && password.equals("admin")) {
      promise.complete("Login Success!!!");
    } else {
      promise.fail("Login failed!!!!");
    }

    //future
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //handle empty promise
//    boolean result = getEmptyPromise().future().succeeded();
//    if (result) {
//      System.out.println("Promise success!!!");
//    }
    boolean result = getEmptyPromise().succeeded();
    if (result) {
      System.out.println("Promise success!!!");
    }
    getDataPromise().onComplete(ar -> {
      System.out.println(ar.result());
    });
    getDataPromise().onComplete(ar -> {
      System.out.println(ar.result());
    });
    getDataPromise().onSuccess(System.out::println);

    auth("admin", "admin").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
    auth("foo", "admin").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
  }
}


public class BasicPromiseVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BasicPromiseVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PromiseVerticle());
  }
}
**********************************************************************************************
 
Legacy Application flow : sync
  
  connect db - connect()
  Query results -queryResult()
  Formate results -formateResult()
  add results into http response stream - writeresults
  send/flush the results to clients - sendresponse

Nested Callback : Callback chaining:
  Handler function is called callback

"The out put of one callback is input to the another callback

   cb1
     --cb2
         -cb3
            --cbN

package com.unisys.vertx.handlers.promise;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class CallbackNestingVerticle extends AbstractVerticle {

  //getUser
  public Future<String> getUser() {
    Promise promise = Promise.promise();
    //biz logic
    String fakeUser = "Subramanian";
    if (fakeUser != null) {
      promise.complete(fakeUser);
    } else {
      promise.fail("User Not Found!!");
    }

    return promise.future();
  }

  //login
  public Future<String> login(String userName) {
    Promise promise = Promise.promise();
    //biz logic
    if (userName.equals("Subramanian")) {
      promise.complete("Login success ");
    } else {
      promise.fail("Login failed!!");
    }

    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //Call getUser
    getUser().onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("getUser Method : " + ar.result());
        //call login methods
        login(ar.result()).onComplete(lar -> {
          //test login success
          if (lar.succeeded()) {
            System.out.println("Login Method :" + lar.result());
          } else {
            System.out.println(lar.cause().getMessage());
          }
        });
      } else {
        System.out.println(ar.cause());
      }
    });

  }
}


public class NestedCallbackUsingPromises extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(NestedCallbackUsingPromises.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new CallbackNestingVerticle());
  }
}
*******************************************************************************************

Task:
 Add one function , which has to verify , that login status "loginSucess", if login success
 show message "Permium Page" else "Guest Page"
 

********************************************************************************************

Nested Callback without onComplete/setHandler:

 class NestedCallbackWithouOnComplete extends AbstractVerticle {

  //passing handler function as parameter : no need to promise/future
  public void getUser(Handler<AsyncResult<String>> aHandler) {
    String fakeUser = "Subramanian";
    //biz logic
    if (fakeUser != null) {
      //handle success
      aHandler.handle(Future.succeededFuture(fakeUser));
    } else {
      aHandler.handle(Future.failedFuture("No User Found"));
    }
  }

  public void login(String userName, Handler<AsyncResult<String>> aHandler) {
    //biz logic
    if (userName.equals("Subramanian")) {
      //handle success
      aHandler.handle(Future.succeededFuture("Login Success"));
    } else {
      aHandler.handle(Future.failedFuture("Login failed"));
    }
  }


  @Override
  public void start() throws Exception {
    super.start();
    //function as parameter : callback function
    getUser(ar -> {
      if (ar.succeeded()) {
        System.out.println("Get User Method");
        login(ar.result(), lar -> {
          if (lar.succeeded()) {
            System.out.println(lar.result());
          } else {
            System.out.println(lar.cause());
          }
        });

      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
  }
}
******************************************************************************************

callback Hell:


    getUser().onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("getUser Method : " + ar.result());
        //call login methods
        login(ar.result()).onComplete(lar -> {
          //test login success
          if (lar.succeeded()) {
            System.out.println("Login Method :" + lar.result());
          } else {
            System.out.println(lar.cause().getMessage());
          }
        });
      } else {
        System.out.println(ar.cause());
      }
    });


 getUser(ar -> {
      if (ar.succeeded()) {
        System.out.println("Get User Method");
        login(ar.result(), lar -> {
          if (lar.succeeded()) {
            System.out.println(lar.result());
          } else {
            System.out.println(lar.cause());
          }
        });

      } else {
        System.out.println(ar.cause().getMessage());
      }
    });

Look at the above code , ask your self

1.is it easy to understand?
2.is it easy to scale
3.is it easy to maintain

No!......This is  what we call is "callback hell".

foo.a(1, res1 -> {
  if (res1.succeeded()) {
    bar.b("abc", 1, res2 -> {
      if (res.succeeded()) {
         baz.c(res3 -> {
           dosomething(res1, res2, res3, res4 -> {
               // (...)
           });
         });
      }
    });
  }
});

can we escape from callback hell problem, how to write better callback based programming?

Yes! 

Vertx provides solution : compose



package com.unisys.vertx.handlers.promise;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;


class ComplexCallbackVerticle extends AbstractVerticle {

  //prepareDatabase
  public Future<Void> prepareDatabase() {
    System.out.println("PrepareDatabase is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  //startHttpDatabase
  public Future<Void> startHttpServer() {
    System.out.println("startHttpServer is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  public Future<Void> startWebContainer() {
    System.out.println("startWebContainer is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //callback based : callback hell
    prepareDatabase().onComplete(ar -> {
      if (ar.succeeded()) {
        startHttpServer().onComplete(httpar -> {
          if (httpar.succeeded()) {
            startWebContainer().onComplete(web -> {
              if (web.succeeded()) {
                System.out.println("All Server is Ready!");
              }
            });
          }

        });
      }
    });
    //compose : avoiding callback hell
    prepareDatabase().compose(handler -> startHttpServer()).compose(web -> startWebContainer()).onComplete(status -> {
      if (status.succeeded()) {
        System.out.println("All Server : Compose is Ready!");
      }
    });
    prepareDatabase().compose(handler -> startHttpServer()).compose(web -> startWebContainer()).onComplete(status -> {
      if (status.succeeded()) {
        System.out.println("All Server : Compose is Ready!");
      }
    });

  }
}


public class CallbackHelloSolution extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackHelloSolution.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new ComplexCallbackVerticle());
  }
}
******************************************************************************************

package com.unisys.vertx.handlers.promise;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;


class HelloMessageCompose extends AbstractVerticle {


  public Future<String> sayWorld() {
    System.out.println("Sayworld is called");
    Promise promise = Promise.promise();
    promise.complete("World");
    return promise.future();
  }

  public Future<String> sayHello(String world) {
    System.out.println("SayHello is called");
    Promise promise = Promise.promise();
    promise.complete("Hello" + world);
    return promise.future();
  }

  public Future<String> sayError() {
    System.out.println("say Error is called");
    Promise promise = Promise.promise();
    promise.fail("failure message");
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
//    sayWorld().onComplete(ar -> {
//      if (ar.succeeded()) {
//        sayHello(ar.result()).onComplete(h -> {
//          System.out.println(h.result());
//        });
//      }
//    });
//    sayError().compose(s -> sayWorld()).compose(m -> sayHello(m)).onComplete(ar -> {
//      if (ar.succeeded()) {
//        System.out.println(ar.result());
//      } else {
//        System.out.println(ar.cause().getMessage());
//      }
//    });

    sayWorld().compose(s -> sayError()).compose(m -> sayHello(m)).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
  }
}


class ComplexCallbackVerticle extends AbstractVerticle {

  //prepareDatabase
  public Future<Void> prepareDatabase() {
    System.out.println("PrepareDatabase is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  //startHttpDatabase
  public Future<Void> startHttpServer() {
    System.out.println("startHttpServer is called");
    Promise promise = Promise.promise();
    // promise.fail("Http Server is broken");
    promise.complete();
    return promise.future();
  }

  public Future<Void> startWebContainer() {
    System.out.println("startWebContainer is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //callback based : callback hell
//    prepareDatabase().onComplete(ar -> {
//      if (ar.succeeded()) {
//        startHttpServer().onComplete(httpar -> {
//          if (httpar.succeeded()) {
//            startWebContainer().onComplete(web -> {
//              if (web.succeeded()) {
//                System.out.println("All Server is Ready!");
//              }
//            });
//          }
//
//        });
//      }
//    });
    //compose : avoiding callback hell
//    prepareDatabase().compose(handler -> startHttpServer()).compose(web -> startWebContainer()).onComplete(status -> {
//      if (status.succeeded()) {
//        System.out.println("All Server : Compose is Ready!");
//      }
//    });
    prepareDatabase().compose(handler -> startHttpServer()).compose(web -> startWebContainer()).onComplete(status -> {
      if (status.succeeded()) {
        System.out.println("All Server : Compose is Ready!");
      } else {
        System.out.println(status.cause().getMessage());

      }
    });

  }
}


public class CallbackHelloSolution extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackHelloSolution.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new ComplexCallbackVerticle());
    // vertx.deployVerticle(new HelloMessageCompose());
  }
}
*********************************************************************************************
Compose method can used for chaining futures(so sequential compostion)

********************************************************************************************

Concurrent Composition:
  It Supports Concurrent Composition(running serverl async operations in parrall) and
sequential composition(chaining)

Implementation:

CompositeFuture.all ,CompositeFuture.any,CompositeFuture.join
*******************************************************************************************

Entering into async programming:
................................

How to async code?

 async code is code which is to be scheduled in os kernal space and processed by event loops.

How to identify the code is async?

 Vertx Provides a high level async apis for building application.

Async api classification:

1.Timer api
2.File System
3.HTTP api
4.TCP/ip api
5.Database drivers api - jdbc,mongo...

etc...........
These apis are given inside vertx as modules.

All async implementations are part of vertx Instance.

vertx.



package com.unisys.vertx.async.timer;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

import java.util.Date;

class Timer extends AbstractVerticle {

  //delay
  private Future<String> delay(long timer, String message) {
    Promise promise = Promise.promise();
    //return result after some time
    //Async code : once timeout , completes
    vertx.setTimer(timer, handler -> {
      //you wrap async result : send result after delay
      promise.complete(message);
    });

    return promise.future();
  }

  //call for every one sec
  private Future<String> heartBeat() {
    Promise promise = Promise.promise();
    //return result after some time
    vertx.setPeriodic(1000, ar -> {
      // promise.complete(new Date().toString());
      System.out.println(new Date().toString());
    });

    return promise.future();
  }

  ;


  @Override
  public void start() throws Exception {
    super.start();

    System.out.println("start");
    delay(1000, "Hey, I am delayed ").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
    delay(2000, "Hey, I am delayed ").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
    delay(5000, "Hey, I am delayed ").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });

    heartBeat().onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
    System.out.println("end");

  }
}


public class TimerAsyncMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(TimerAsyncMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new Timer());
  }
}
**********************************************************************************************
Vertx is good for non blocking application.
Vertx is good for non blocking io application.

IO :
 IO is every Where.
Every pl , traditionally blocking io.
Vertx offers nonblocking io  / async io : io operations never block current process,to be scheduled separatelly.

Types of io:
1.file system io  - read,write from disk files
2.Networking io -  http,tcp/ip,dns,datagram....
3.Database io


File System Api:
................
package com.unisys.vertx.async.fs;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.file.FileSystem;
import io.vertx.example.util.Runner;


class FileServiceVerticle extends AbstractVerticle {

  private Future<String> readFile() {
    Promise promise = Promise.promise();
    //Async file read operation
    FileSystem fs = vertx.fileSystem();
    fs.readFile("assets/hello.txt", fileHandler -> {
      if (fileHandler.succeeded()) {
        System.out.println("File is ready!");
        promise.complete(fileHandler.result().toString());
      } else {
        promise.fail(fileHandler.cause());
      }
    });


    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Start");
    readFile().onComplete(far -> {
      if (far.succeeded()) {
        System.out.println(far.result());
      } else {
        System.out.println(far.cause().getMessage());
      }
    });
    System.out.println("end");
  }
}


public class FileSystemMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FileSystemMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new FileServiceVerticle());
  }
}

















