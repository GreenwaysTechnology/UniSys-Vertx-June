                                       Vert.x


What is Vert.X?

 Vert.x is a tool-kit to build
       functional style,
       non blocking or async,
       poly glot,
       Event driven,
       Reactive, 
            Distributed Application(MicroService) on 
                       JVM

Non Blocking and Async Programming:

Concurrency:
  Doing many thing, at the same time
Multi threading


Runtime:

  Program which is abstraction for applications 
  Program which is between the os and application.

Every application must have runtime which is running on computers
EG:
 jvm

Program Types:

1. active program: The program in Main Memory.
    ->Process : Program in exuction
 any program, in main memory must have , structure : process structure.
Any runtime will become process
 java -JVM-Process--->

Mostly all process are c programs.

2.passive program ; program which is not in main memory/ which is not accessed by cpu.


Heap:
  The ds for allocating dynamic memory .

Stack:
  The ds for  allocating dynamic memory.

Program data;

 it is ds for passive programs of running application.


What is Object?

The term object refers "memory representation of variables and methods in side heap of  
a process" : collective memory.

since memory representation , will have a structure.

passive code     ----->Active code
class Employee {
  state:variables
  methods
  public void calculate(){
  	//biz logic
  }
 
} ---->new Employee()---->

What is the structure of object?

state
vtable

why vtable?
 vtable will have only reference of methods passivly.
 because of memory management.


****************************************************************************************

Stack frame : single execution point of   a method.

Can i run multi stack frame at the same time?
 Generally no!
But yes!

someref.somemethod()---push into stack----frame is created---running..

someref.somemethod1()---push into stack----frame is created---running..

thread of execution / "thread" : 

  method of execution - single stack frame


Process Level Multi threading:

1.Process is responsible for creating and managing life cycles of frames(threads).

This is the architecture we have been using for long time.

This  architecture is called Process level Concurrency

******************************************************************************************

is there any problems with process level concurrency/multithreading?



Use case of network computing?

Java Networking and concurrency (Servlet)

 Servlet is program which has methods -GET,POST =>DOGET,DOPOST.
  Servlet is exucted on jvm(Tomcat)

Traditional web work flow:

			       JVM
				|
client---http--req1-------WebServer(Tomcat)----create a thread(get)---frame(thread)
client---http--req1-------WebServer(Tomcat)----create a thread(get)---frame(thread)
client---http--req1-------WebServer(Tomcat)----create a thread(get)---frame(thread)
client---http--req1-------WebServer(Tomcat)----create a thread(get)---frame(thread)   
client---http--req1-------WebServer(Tomcat)----create a thread(get)---frame(thread)



Evils of "Process level multi threading".

1.Blocking: use case , i want to read file and return that file to users.


client---http--req1-------WebServer(Tomcat)----create a thread()---frame(thread) --
                                                                            
                                                                       to read disk file

While reading disk file, the thread is blocked until file content is ready.
While thread is blocked, resources are going to be waste, 

2.dead lock may happen

3.starativation

4.reace conditions.

         since tomcat is managing all thread life cycles, problems starts.

*********************************************************************************************


What is solution?

 isloate process level threading.
 Dont ask process to create multi threading.

                                   
                                 "Worker thread Model" (OS Kernal Threads). 
					 |
				   Non Blocking
					 |
				      Async


The process(Runtime) never creates any threads,handles thread biz logic rather than 
process will delegate to the OS , to perform

We are going to offload the jobs from process level to os level : Non blocking archiecture.



Java and Non blocking Programming:

 Does java support non blocking(worker-thread) model?
 Does jvm supports non blocking,evented concurrency?

No!

Yes from Java 7 called "Dolphin".

Dolphin introduced experimental model for building fast disk io, called "NIO"
  NONBlocking IO. But not based on  worker thread model.

That was beginning

  due to low support from the java, only disk io was implemented: nio

later it was improved to support read and write using nio for TCP/IP . but it is still not
not "Worker thread Model".

...............................................................................................
                                   Reactor Design Pattern
.............................................................................................

                All non blocking architectures(worker-thread( are designed with  
                         "Reactor Design pattern" Pattern.



Reactor design pattern implementations:

1.nodejs
2.Vertx
3.Project Reactor (used in springWebFlux)
4.nginx
etc.......

Reactor design pattern in java:
..............................

NETTY : First Non blocking and async architecture for jvm.

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns

		       Netty
		         |
          	      nettycore
			 |
			nio
			 |
		        jvm

Netty project provides:
1.nio only for disk io but netty provided more io like
   tcp/ip,sockets,udp,http
  non blocking  
    netty uses "Reactor Model" internaly



Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library



 		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm
*********************************************************************************************



                                    Vertx


Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM. initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.


			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM



Objective of VertX:
   
    100% non blocking applications on jvm.



NonBlocking IO Apis

                NonBlocking IO Application -VertApplication
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM



vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
		|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				 |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM
**********************************************************************************************

Event driven Programming;
........................
Vertx is powered by non blocking with help of "Built in Event Mechnism" Called "Event Bus".
  -Application events

Dont call us,we will call you ----- Event Driven programming



Req : to read database records

  Client----req -----Vertx---|---delegate db operations--db

					db operations done
					<--inform vertx 
*******************************************************************************************

Vertx Tech Stack
  Build async,non blocking Apps

Spring is collection of projects called modules
  like core,data,mvc,integration,microservice.............

Like Spring Vertx is also collection projects

Vertx-core
vertx-web
Vertx-Data
Vertx-Reactive Extension
Vertx-Microservices
Vertx-Messaging
Vertx-Security
Vertx-Integration
Vertx-Devops Engineering
Vertx-Testing
Vertx-Clusters
Vertx-Services
Vertx-Cloud

******************************************************************************************

Vertx-Core:

Writing TCP clients and servers
Writing HTTP clients and servers including support for WebSockets
The Event bus
Shared data - local maps and clustered distributed maps
Periodic and delayed actions
Deploying and undeploying Verticles
Datagram Sockets
DNS client
File system access
High availability
Native transports
Clustering   
*******************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////


Does Vertx 100% NonBlocking Platform?
  Yes!, some of the API in Vertx is blocking  , particullary fs apis.

////////////////////////////////////////////////////////////////////////////////////////////

Vertx Application setup /Project Setup:
.......................................

ways :

1.maven
2.Gradle

1.plain maven project, add vertx depedencies,You can use template entry method provided by
vertx .

2.Vertx Starter project

3.Vertx maven cli project

********************************************************************************************

In terminal window

Run :

Way 1: Using maven plugin :

>mvn package exec:java

open browser

http://localhost:8888

Way 2: fat jar

java -jar target/vertx-start-project-1.0-SNAPSHOT-fat.jar


Way 3 : vertx cli tool

no need to compile,
no need .class files
only source code 

C:\session\UniSys-Vertx\unisysverxdemo\src\main\java\com\unisys\vertx>vertx run MainVerticle.java


Way 4 : via Runner utility class : looks like main methods


Have Runner class

package com.unisys.vertx;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

public class MainVerticleRunnerDemo extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(MainVerticleRunnerDemo.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Hello Vertx!!!");
  }
}
******************************************************************************************

Vertx Core Concepts:
....................

What is vertx application?

 Vertx is collection of objects.

Vertx Objects
1.Verticle
2.Vertx 

Vertx is Core  and Container object , which contains other objects ==== Spring Container.

How to create vertx object?

vertx offers only high level apis mostly through interfaces, implementations classes we cant see.

how to create vertx instance?

ways

1.using Vertx factory api

public class HelloWorldVertx {
  public static void main(String[] args) {
    //Create Vertx Instance
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx.toString());
  }

2.Via  class called AbstractVerticle

A verticle is a piece of code that can be "deployed" by Vert.x.
  -deployment : make avaialble on Vertx runtime.
 Verticle is Object , can do lot of things which is deployment on Vertx Instance

Use of verticles with Vert.x is entirely optional, but if you use them they provide an actor-like deployment and concurrency model, out of the box

The verticles communicate with each other by sending messages over the EventBus.

******************************************************************************************

if you want to create your own verticles, then you have to inherit AbstractVerticle

if you inherit AbstractVertcle, vertx reference is availble automatically,you need not use
factory method.

Abstract verticle provides life cycle methods

start
  - is called once , you deploy the verticle on vertx
stop
 - is called once , you undeploy the verticle from vertx



package com.unisys.vertx;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import io.vertx.example.util.Runner;

//separate Verticle
class HelloWorldVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("HelloWorld Verticle is ready");
    System.out.println(vertx.toString());
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("Hello World is stoped");
  }
}

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Greeter Verticle is ready");
    System.out.println(vertx.toString());
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("Hello World is stoped");
  }
}

public class HelloWorldVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    //Vertx vertx = Vertx.vertx();
    //vertx.deployVerticle(new HelloWorldVerticle());
    Runner.runExample(HelloWorldVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new HelloWorldVerticle());
    vertx.deployVerticle(new GreeterVerticle());
  }
}
********************************************************************************************
Vertx Handlers - Event Handlers:
................................

Vertx Event Handlers can be in written in two ways

1.Future && Promise Pattern
2.Reactive Pattern - RxJava2

if you come from java script && node.js background,you know the concept called "Callback
function" - callback function is other wise called as "listener function" and "handler function".

1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop starts processing.


The result of async opertion could be either success or failure

*********************************************************************************************

Future Interface 
				AsyncResult       Handler
				-------------------------
					   |
				         Future


CallBack programming : without async implementation:
...................................................

Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation
 Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate
 inside this api.
    

Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> setHandler(Handler<AsyncResult<T>> handler)
3.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
4.onSuccess
5.onFailure


  AsyncResult interface apis

   -result() - get the success result sent by Future
   -cause()   -get the failure result sent by Future
   -succeed() -test whether it was success or failure
   -failed()  -test whether it was failure or success


package com.unisys.vertx.handlers.future;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.example.util.Runner;

//Future Demo :
class BasicFutureVerticle extends AbstractVerticle {

  //various way of sending success and failure response

  //way 1 : sending empty  success response
  public Future<Void> getEmptyFuture() {
    //Create Future Object
    Future future = Future.future();
    //send empty response
    future.complete();
    //future
    return future;
  }

  //Sending Response , Response type could be any thing from primitive to Objects,lists,arrays,json
  public Future<String> getDataFuture() {
    //Create Future Object
    Future future = Future.future();
    //declare fake response
    String message = "Hello,How are you!,I am coming from Future";
    future.complete(message);
    //future
    return future;
  }

  //Sending failure Response :  String message /Throwable Instance
  public Future<String> getErrorMessage() {
    //Create Future Object
    Future future = Future.future();
    //declare fake response
    String errorMessage = "Sorry,Something went Wrong!!!";
    future.fail(errorMessage);
    //future
    return future;
  }

  //Success and failure based biz logic

  public Future<String> auth(String userName, String password) {
    //Create Future Object
    Future future = Future.future();
    //biz logic
    if (userName.equals("admin") && password.equals("admin")) {
      future.complete("Login Success!!!");
    } else {
      future.fail("Login failed!!!!");
    }

    //future
    return future;
  }


  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Future Verticle is ready!!");
    Future future = null;

    //grab empty response :Handlers api
    future = getEmptyFuture();
    if (future.succeeded()) {
      System.out.println("Future is success");
    } else {
      System.out.println("Future is failed!");
    }
    //Grab data response : Handlers api
    future = getDataFuture();
    //old style
    future.setHandler(new Handler<AsyncResult>() {
      @Override
      public void handle(AsyncResult asyncResult) {
        //test success or failure
        if (asyncResult.succeeded()) {
          //grab result
          System.out.println(asyncResult.result());
        } else {
          System.out.println(asyncResult.cause());
        }

      }
    });
    ////lambda + setHandler / onComplete + fluent pattern
    getDataFuture().setHandler(asyncResult -> {
      if (asyncResult.succeeded()) {
        //grab result
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    getDataFuture().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        //grab result
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    //Failure Resonse
    getErrorMessage().onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause().getMessage());
      } else {

      }
    });

    //biz logic
    auth("admin", "admin").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
    auth("foo", "admin").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
    //only success
    //getDataFuture().onSuccess(result-> System.out.println(result));
    getDataFuture().onSuccess(System.out::println);
    getErrorMessage().onFailure(System.out::println);

  }
}


public class BasicHanldersUsingFuture extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BasicHanldersUsingFuture.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new BasicFutureVerticle());
  }
}
**********************************************************************************************
Promise:

Promise is async abstraction largly promoted by javascript community.
Dont Compare js javascript with Vertx Promise.

Promise is semantically meaningfull abstraction for handling asyn results.

Many times developers confuse with java Fututre and Vertx Future.

Promises can't be processed directly with onComplete/setHandler/OnSuccecc/onFailure apis

if you want process, you have to convert "Promise to Future" again.

promise conversion can be done when you process or promise conversion can be before process.


Way 1 : return promise and convert future later

  public Promise<Void> getEmptyPromise() {
    //Create Promise Object
    Promise promise = Promise.promise();
    //send empty response
    promise.complete();
    //future
    return promise;
  }

inside another api
 boolean result = getEmptyPromise().future().succeeded();
    if (result) {
      System.out.println("Promise success!!!");
    }


Way 2: return promise and convert future in the api itself


public Future<Void> getEmptyPromise() {
    //Create Promise Object
    Promise promise = Promise.promise();
    //send empty response
    promise.complete();
    //future
    return promise.future();
  }

boolean result = getEmptyPromise().succeeded();
      if (result) {
        System.out.println("Promise success!!!");
      }


Code:
package com.unisys.vertx.handlers.promise;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class PromiseVerticle extends AbstractVerticle {

  // //way 1 : sending empty  success response
//  public Promise<Void> getEmptyPromise() {
//    //Create Promise Object
//    Promise promise = Promise.promise();
//    //send empty response
//    promise.complete();
//    //future
//    return promise;
//  }

  public Future<Void> getEmptyPromise() {
    //Create Promise Object
    Promise promise = Promise.promise();
    //send empty response
    promise.complete();
    //future
    return promise.future();
  }

  //Sending Response , Response type could be any thing from primitive to Objects,lists,arrays,json
  public Future<String> getDataPromise() {
    //Create Promise Object
    Promise promise = Promise.promise();
    //declare fake response
    String message = "Hello,How are you!,I am coming from Future";
    promise.complete(message);
    //future
    return promise.future();
  }

  public Future<String> auth(String userName, String password) {
    //Create Promise Object
    Promise promise = Promise.promise();
    //biz logic
    if (userName.equals("admin") && password.equals("admin")) {
      promise.complete("Login Success!!!");
    } else {
      promise.fail("Login failed!!!!");
    }

    //future
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //handle empty promise
//    boolean result = getEmptyPromise().future().succeeded();
//    if (result) {
//      System.out.println("Promise success!!!");
//    }
    boolean result = getEmptyPromise().succeeded();
    if (result) {
      System.out.println("Promise success!!!");
    }
    getDataPromise().onComplete(ar -> {
      System.out.println(ar.result());
    });
    getDataPromise().onComplete(ar -> {
      System.out.println(ar.result());
    });
    getDataPromise().onSuccess(System.out::println);

    auth("admin", "admin").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
    auth("foo", "admin").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
  }
}


public class BasicPromiseVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BasicPromiseVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PromiseVerticle());
  }
}
**********************************************************************************************
 
Legacy Application flow : sync
  
  connect db - connect()
  Query results -queryResult()
  Formate results -formateResult()
  add results into http response stream - writeresults
  send/flush the results to clients - sendresponse

Nested Callback : Callback chaining:
  Handler function is called callback

"The out put of one callback is input to the another callback

   cb1
     --cb2
         -cb3
            --cbN

package com.unisys.vertx.handlers.promise;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class CallbackNestingVerticle extends AbstractVerticle {

  //getUser
  public Future<String> getUser() {
    Promise promise = Promise.promise();
    //biz logic
    String fakeUser = "Subramanian";
    if (fakeUser != null) {
      promise.complete(fakeUser);
    } else {
      promise.fail("User Not Found!!");
    }

    return promise.future();
  }

  //login
  public Future<String> login(String userName) {
    Promise promise = Promise.promise();
    //biz logic
    if (userName.equals("Subramanian")) {
      promise.complete("Login success ");
    } else {
      promise.fail("Login failed!!");
    }

    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //Call getUser
    getUser().onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("getUser Method : " + ar.result());
        //call login methods
        login(ar.result()).onComplete(lar -> {
          //test login success
          if (lar.succeeded()) {
            System.out.println("Login Method :" + lar.result());
          } else {
            System.out.println(lar.cause().getMessage());
          }
        });
      } else {
        System.out.println(ar.cause());
      }
    });

  }
}


public class NestedCallbackUsingPromises extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(NestedCallbackUsingPromises.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new CallbackNestingVerticle());
  }
}
*******************************************************************************************

Task:
 Add one function , which has to verify , that login status "loginSucess", if login success
 show message "Permium Page" else "Guest Page"
 

********************************************************************************************

Nested Callback without onComplete/setHandler:

 class NestedCallbackWithouOnComplete extends AbstractVerticle {

  //passing handler function as parameter : no need to promise/future
  public void getUser(Handler<AsyncResult<String>> aHandler) {
    String fakeUser = "Subramanian";
    //biz logic
    if (fakeUser != null) {
      //handle success
      aHandler.handle(Future.succeededFuture(fakeUser));
    } else {
      aHandler.handle(Future.failedFuture("No User Found"));
    }
  }

  public void login(String userName, Handler<AsyncResult<String>> aHandler) {
    //biz logic
    if (userName.equals("Subramanian")) {
      //handle success
      aHandler.handle(Future.succeededFuture("Login Success"));
    } else {
      aHandler.handle(Future.failedFuture("Login failed"));
    }
  }


  @Override
  public void start() throws Exception {
    super.start();
    //function as parameter : callback function
    getUser(ar -> {
      if (ar.succeeded()) {
        System.out.println("Get User Method");
        login(ar.result(), lar -> {
          if (lar.succeeded()) {
            System.out.println(lar.result());
          } else {
            System.out.println(lar.cause());
          }
        });

      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
  }
}
******************************************************************************************

callback Hell:


    getUser().onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("getUser Method : " + ar.result());
        //call login methods
        login(ar.result()).onComplete(lar -> {
          //test login success
          if (lar.succeeded()) {
            System.out.println("Login Method :" + lar.result());
          } else {
            System.out.println(lar.cause().getMessage());
          }
        });
      } else {
        System.out.println(ar.cause());
      }
    });


 getUser(ar -> {
      if (ar.succeeded()) {
        System.out.println("Get User Method");
        login(ar.result(), lar -> {
          if (lar.succeeded()) {
            System.out.println(lar.result());
          } else {
            System.out.println(lar.cause());
          }
        });

      } else {
        System.out.println(ar.cause().getMessage());
      }
    });

Look at the above code , ask your self

1.is it easy to understand?
2.is it easy to scale
3.is it easy to maintain

No!......This is  what we call is "callback hell".

foo.a(1, res1 -> {
  if (res1.succeeded()) {
    bar.b("abc", 1, res2 -> {
      if (res.succeeded()) {
         baz.c(res3 -> {
           dosomething(res1, res2, res3, res4 -> {
               // (...)
           });
         });
      }
    });
  }
});

can we escape from callback hell problem, how to write better callback based programming?

Yes! 

Vertx provides solution : compose



package com.unisys.vertx.handlers.promise;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;


class ComplexCallbackVerticle extends AbstractVerticle {

  //prepareDatabase
  public Future<Void> prepareDatabase() {
    System.out.println("PrepareDatabase is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  //startHttpDatabase
  public Future<Void> startHttpServer() {
    System.out.println("startHttpServer is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  public Future<Void> startWebContainer() {
    System.out.println("startWebContainer is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //callback based : callback hell
    prepareDatabase().onComplete(ar -> {
      if (ar.succeeded()) {
        startHttpServer().onComplete(httpar -> {
          if (httpar.succeeded()) {
            startWebContainer().onComplete(web -> {
              if (web.succeeded()) {
                System.out.println("All Server is Ready!");
              }
            });
          }

        });
      }
    });
    //compose : avoiding callback hell
    prepareDatabase().compose(handler -> startHttpServer()).compose(web -> startWebContainer()).onComplete(status -> {
      if (status.succeeded()) {
        System.out.println("All Server : Compose is Ready!");
      }
    });
    prepareDatabase().compose(handler -> startHttpServer()).compose(web -> startWebContainer()).onComplete(status -> {
      if (status.succeeded()) {
        System.out.println("All Server : Compose is Ready!");
      }
    });

  }
}


public class CallbackHelloSolution extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackHelloSolution.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new ComplexCallbackVerticle());
  }
}
******************************************************************************************

package com.unisys.vertx.handlers.promise;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;


class HelloMessageCompose extends AbstractVerticle {


  public Future<String> sayWorld() {
    System.out.println("Sayworld is called");
    Promise promise = Promise.promise();
    promise.complete("World");
    return promise.future();
  }

  public Future<String> sayHello(String world) {
    System.out.println("SayHello is called");
    Promise promise = Promise.promise();
    promise.complete("Hello" + world);
    return promise.future();
  }

  public Future<String> sayError() {
    System.out.println("say Error is called");
    Promise promise = Promise.promise();
    promise.fail("failure message");
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
//    sayWorld().onComplete(ar -> {
//      if (ar.succeeded()) {
//        sayHello(ar.result()).onComplete(h -> {
//          System.out.println(h.result());
//        });
//      }
//    });
//    sayError().compose(s -> sayWorld()).compose(m -> sayHello(m)).onComplete(ar -> {
//      if (ar.succeeded()) {
//        System.out.println(ar.result());
//      } else {
//        System.out.println(ar.cause().getMessage());
//      }
//    });

    sayWorld().compose(s -> sayError()).compose(m -> sayHello(m)).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
  }
}


class ComplexCallbackVerticle extends AbstractVerticle {

  //prepareDatabase
  public Future<Void> prepareDatabase() {
    System.out.println("PrepareDatabase is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  //startHttpDatabase
  public Future<Void> startHttpServer() {
    System.out.println("startHttpServer is called");
    Promise promise = Promise.promise();
    // promise.fail("Http Server is broken");
    promise.complete();
    return promise.future();
  }

  public Future<Void> startWebContainer() {
    System.out.println("startWebContainer is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //callback based : callback hell
//    prepareDatabase().onComplete(ar -> {
//      if (ar.succeeded()) {
//        startHttpServer().onComplete(httpar -> {
//          if (httpar.succeeded()) {
//            startWebContainer().onComplete(web -> {
//              if (web.succeeded()) {
//                System.out.println("All Server is Ready!");
//              }
//            });
//          }
//
//        });
//      }
//    });
    //compose : avoiding callback hell
//    prepareDatabase().compose(handler -> startHttpServer()).compose(web -> startWebContainer()).onComplete(status -> {
//      if (status.succeeded()) {
//        System.out.println("All Server : Compose is Ready!");
//      }
//    });
    prepareDatabase().compose(handler -> startHttpServer()).compose(web -> startWebContainer()).onComplete(status -> {
      if (status.succeeded()) {
        System.out.println("All Server : Compose is Ready!");
      } else {
        System.out.println(status.cause().getMessage());

      }
    });

  }
}


public class CallbackHelloSolution extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackHelloSolution.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new ComplexCallbackVerticle());
    // vertx.deployVerticle(new HelloMessageCompose());
  }
}
*********************************************************************************************
Compose method can used for chaining futures(so sequential compostion)

********************************************************************************************

Concurrent Composition:
  It Supports Concurrent Composition(running serverl async operations in parrall) and
sequential composition(chaining)

Implementation:

CompositeFuture.all ,CompositeFuture.any,CompositeFuture.join
*******************************************************************************************

Entering into async programming:
................................

How to async code?

 async code is code which is to be scheduled in os kernal space and processed by event loops.

How to identify the code is async?

 Vertx Provides a high level async apis for building application.

Async api classification:

1.Timer api
2.File System
3.HTTP api
4.TCP/ip api
5.Database drivers api - jdbc,mongo...

etc...........
These apis are given inside vertx as modules.

All async implementations are part of vertx Instance.

vertx.



package com.unisys.vertx.async.timer;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

import java.util.Date;

class Timer extends AbstractVerticle {

  //delay
  private Future<String> delay(long timer, String message) {
    Promise promise = Promise.promise();
    //return result after some time
    //Async code : once timeout , completes
    vertx.setTimer(timer, handler -> {
      //you wrap async result : send result after delay
      promise.complete(message);
    });

    return promise.future();
  }

  //call for every one sec

//call for every one sec
  private void heartBeat(Handler<AsyncResult<String>> aHandler) {
    //return result after some time
    vertx.setPeriodic(1000, ar -> {
      aHandler.handle(Future.succeededFuture(new Date().toString()));
    });
  }


  @Override
  public void start() throws Exception {
    super.start();

    System.out.println("start");
    delay(1000, "Hey, I am delayed ").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
    delay(2000, "Hey, I am delayed ").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
    delay(5000, "Hey, I am delayed ").onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });

 
    heartBeat(handler -> {
      System.out.println(handler.result());
    });
    System.out.println("end");

  }
}


public class TimerAsyncMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(TimerAsyncMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new Timer());
  }
}



**********************************************************************************************
Vertx is good for non blocking application.
Vertx is good for non blocking io application.

IO :
 IO is every Where.
Every pl , traditionally blocking io.
Vertx offers nonblocking io  / async io : io operations never block current process,to be scheduled separatelly.

Types of io:
1.file system io  - read,write from disk files
2.Networking io -  http,tcp/ip,dns,datagram....
3.Database io


File System Api:
................
package com.unisys.vertx.async.fs;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.file.FileSystem;
import io.vertx.example.util.Runner;


class FileServiceVerticle extends AbstractVerticle {

  private Future<String> readFile() {
    Promise promise = Promise.promise();
    //Async file read operation
    FileSystem fs = vertx.fileSystem();
    fs.readFile("assets/hello.txt", fileHandler -> {
      if (fileHandler.succeeded()) {
        System.out.println("File is ready!");
        promise.complete(fileHandler.result().toString());
      } else {
        promise.fail(fileHandler.cause());
      }
    });


    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Start");
    readFile().onComplete(far -> {
      if (far.succeeded()) {
        System.out.println(far.result());
      } else {
        System.out.println(far.cause().getMessage());
      }
    });
    System.out.println("end");
  }
}


public class FileSystemMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FileSystemMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new FileServiceVerticle());
  }
}

*********************************************************************************************
How Verticles communicate each other? Verticles Communication

Object communication:

class OrderService{

 private OrderRepository repo;

 public OrderService(){
 }

 public OrderService(OrderRepository repo){
       this.repo = repo;
 }
  //setter and getters

  public void saveOrder(Object somedata){
   
        repo.save(somedata);
  }

}

class OrderRepository{

   public void save(Object somedata){}

}

//
OrderRepository repo = new OrderRepository();
OrderService service = new OrderService(repo);
service.saveOrder(somedata);


Why object communication?

 data exchange

Any other way these two objects can communicate each other?

Distributed programming, where programs can talk each, distributed objects , can talk each other.

communication channel :  Protocals - tcp/ip, http 


Message Driven Architecture  : MOM

-RabbitMq,Kafka


*********************************************************************************************

In Vertx, How objects(Verticles) communicate each other?

 Via MOM like architecture, event bus

What is event Bus?

 Event Bus is nerve of vertx systems.

How verticle has been designed to adopt this architecture?

Verticle follows a design pattern  "Actor-like Model" ---->Actor Model design pattern
https://doc.akka.io/docs/akka/current/typed/guide/actors-intro.html

Event Bus:

1.Event Bus can allow verticles sends data from one place to another place
2.Event Bus forms a distributed peer-to-peer messaging system spannining multiple server nodes
  and multiple browers.
3.Event bus allows sending messages in three ways
  1.pub/sub : one to many
  2.point-to-point : one to one
  3.request-reply(reponse) - one to one with acknowlegement.

4.Event bus identifies clients via "addressing"
   Messages are sent on the event bus to an "address"
   Address schemes can be any naming convention, recommendation is dns model "in.news.covid"
   

5.Handlers
   Since vertx is non blocking, messages are processed by handlers.
   You have to register a handler at an address

6.Type of Data
   Data type of message could be any primitive-int,char,boolean,String, Buffer,JSON


****************************************************************************************

PUB-SUB :

package com.unisys.vertx.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;


//Subscriber -1
class NewsSevenVerticle extends AbstractVerticle {

  //listen for message
  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("News 7's Today News : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

//Subscriber 2
class BBCVerticle extends AbstractVerticle {

  //listen for message
  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("BBC's Today News : " + news.body());
    });
  }
  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

//Publisher
class NewsPublisherVerticle extends AbstractVerticle {

  //api to publish message
  private void publishNews() {
    //publish news after some delay
    vertx.setTimer(1000, h -> {
      //publish : pub-sub
      vertx.eventBus().publish("news.in.covid", "Last 24 hrs, 15000 covid patients in India");

    });


  }

  @Override
  public void start() throws Exception {
    super.start();
    //call publish news
    publishNews();
  }
}

public class EventBusApp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusApp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new NewsPublisherVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
  }
}
*********************************************************************************

Point to Point : One Sender , One Receiver.


package com.unisys.vertx.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;


class CentralFinanceVerticle extends AbstractVerticle {

  private void alertNotification() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("notification.tn.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("Alert From Tamil Nadu : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    alertNotification();
  }
}


//Subscriber -1
class NewsSevenVerticle extends AbstractVerticle {

  //listen for message
  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("News 7's Today News : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

//Subscriber 2
class BBCVerticle extends AbstractVerticle {

  //listen for message
  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("BBC's Today News : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

//Publisher
class NewsPublisherVerticle extends AbstractVerticle {

  //api to publish message
  private void publishNews() {
    //publish news after some delay
    vertx.setTimer(1000, h -> {
      //publish : pub-sub
      vertx.eventBus().publish("news.in.covid", "Last 24 hrs, 15000 covid patients in India");

    });

  }

  private void sendNotification() {
    vertx.setTimer(1500, h -> {
      //point-to-point
      vertx.eventBus().send("notification.tn.covid", "We have not received any update on Fund!");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    //call publish news
    publishNews();
    //point to point
    sendNotification();
  }
}

public class EventBusApp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusApp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new NewsPublisherVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new CentralFinanceVerticle());
  }
}

*******************************************************************************************

//Request--Reply
package com.unisys.vertx.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;


//request-reply
class HealthEmerencyVerticle extends AbstractVerticle {

  private void requestReply() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("alert.tn.covid");
    //handle/process the message/news
    consumer.handler(alert -> {
      System.out.println("Alert From Hosiptial : " + alert.body());
      alert.reply("Patient is crictal!! Need More Attention!!!");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    requestReply();
  }
}


class CentralFinanceVerticle extends AbstractVerticle {

  private void alertNotification() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("notification.tn.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("Alert From Tamil Nadu : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    alertNotification();
  }
}


//Subscriber -1
class NewsSevenVerticle extends AbstractVerticle {

  //listen for message
  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("News 7's Today News : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

//Subscriber 2
class BBCVerticle extends AbstractVerticle {

  //listen for message
  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("BBC's Today News : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

//Publisher
class NewsPublisherVerticle extends AbstractVerticle {

  //api to publish message
  private void publishNews() {
    //publish news after some delay
    vertx.setTimer(1000, h -> {
      //publish : pub-sub
      vertx.eventBus().publish("news.in.covid", "Last 24 hrs, 15000 covid patients in India");

    });

  }

  private void sendNotification() {
    vertx.setTimer(1500, h -> {
      //point-to-point
      vertx.eventBus().send("notification.tn.covid", "We have not received any update on Fund!");
    });
  }

  private void sendAlert() {
    vertx.setTimer(100, h -> {
      //request-reply
      vertx.eventBus().request("alert.tn.covid", "We have send medical Reports of Mr X", ar -> {
        if (ar.succeeded()) {
          System.out.println("Reply/Response : " + ar.result().body());
        }
      });
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    //call publish news
    publishNews();
    //point to point
    sendNotification();
    //request-reply
    sendAlert();
  }
}

public class EventBusApp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusApp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new NewsPublisherVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new CentralFinanceVerticle());
    vertx.deployVerticle(new HealthEmerencyVerticle());
  }
}
**********************************************************************************************
Objects in vertx : Data Representation

Buffer:

1.Verticles running in vertx often need to process blocks of data.
2.For instance , data from an incomming http request, data loaded from the disk or data generated as response to http request etc.
3.A Buffer in vertx can hold binary data.
4.Buffer is similar to byte array, except the buffer can expand its capacity dynamically
 as you write data to it.

package com.unisys.data.format;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;

public class BufferDemo  extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BufferDemo.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //Buffer
    Buffer buffer = Buffer.buffer();
    buffer.appendString("Hello");
    buffer.appendString("Hai");
    buffer.appendString("Welcome");
    buffer.appendString("How are you");
    buffer.appendString("this is binary data");
    System.out.println(buffer.length());
    System.out.println(buffer.toString());
  }
}
**********************************************************************************************
JSON Object :Data Interchange format 

Vertx provides a Json Objects

1.JsonObject
2.JsonArray


package com.unisys.data.format;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class VisitorFuture extends AbstractVerticle {

  public Future<JsonObject> getVisitor() {
    Promise promise = Promise.promise();
    JsonObject address = new JsonObject();
    address.put("city", "coimbatore").put("street", "10th street").put("state", "Tamil Nadu");
    JsonObject visitor = new JsonObject();
    visitor.put("name", "subramanian").put("address", address);
    promise.complete(visitor);

    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    getVisitor().onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("Visitor future");
        System.out.println(ar.result().encodePrettily());
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
  }
}


public class JSONDemo extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONDemo.class);
  }

  @Override
  public void start() throws Exception {
    super.start();

    //json object creation.
    JsonObject address = new JsonObject();
    address.put("city", "coimbatore").put("street", "10th street").put("state", "Tamil Nadu");
    System.out.println(address.encode());
    System.out.println(address.encodePrettily());

    JsonObject visitor = new JsonObject();
    visitor.put("name", "subramanian").put("address", address);
    System.out.println(visitor.encodePrettily());

    //Getting key-values from the json
    System.out.println("City " + address.getString("city"));
    System.out.println(visitor.getString("name") + visitor.getJsonObject("address").getString("city"));

    //JSON ARRAYS
    JsonArray list = new JsonArray();
    list.add(visitor).add(visitor);
    System.out.println(list.encodePrettily());

    //read data from json array
    list.forEach(v -> {
      System.out.println(v);
    });
    vertx.deployVerticle(new VisitorFuture());

  }
}
*********************************************************************************************
Blocking code and vertx?

 Does vertx support blocking api?
  Yes!....

1.blocking code should not be executed inside event loop.
   where as nonblocking code is executed by event loop--event queue,publishers

Blocking code could be

 1.Thread.sleep
 2.if thread is waiting for a lock
 3.any synchronized code
 4.database operation in traditional ways
 5.if any biz logic takes lot of time 
 6.blocking file system apis

etc....

There is rule /recommendation : "Dont block event loop"

what if i want blocking code inside non blocking code. vertx provides solution.

blocking code can be executed by vertx "Worker Pool threads" (Threads are mananged by
vertx itself).

vertx.<Type>executeBlocking(blockinghandler,resultHandler)



package com.unisys.vertx.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

public class BlockingInsideNonBlocking extends AbstractVerticle {

  public static void main(String[] args) {
    Runner.runExample(BlockingInsideNonBlocking.class);
  }

  @Override
  public void start() throws Exception {
    super.start();

    vertx.<String>executeBlocking(blockingHandler -> {

      try {
        System.out.println("Waiting in Blocking Mode!!!");
        Thread.sleep(5000);
      } catch (InterruptedException e) {
        System.out.println(e.getMessage());
      }
      //after 5000ms, send some data to result Handler
      String message = "Sleep is done,hand over me to Some one to handle";
      blockingHandler.complete(message);

    }, resultHandler -> {
      //you can perform non blocking operations here
      System.out.println("Blocking operation is completed!!!");
      if (resultHandler.succeeded()) {
        System.out.println(resultHandler.result());
      }
    });

  }
}
********************************************************************************************
Web : HTTP

How to build non blocking web application

vertx offers low level api called
 vertx.createHttpServer()

Objects:

1.HttpServer
2.HttpServerRequest
3.HttpServerResponse
All these objects are created already by vertx and only we references.


package com.unisys.vertx.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class HelloWorldWebApp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(HelloWorldWebApp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //create WebServer , Handle request  and Send Response
    HttpServer server = vertx.createHttpServer();

    //Handle Request
    server.requestHandler(context -> {
      //context is container object , having HttpResponse and HttpRequest.
      HttpServerResponse response = context.response();
      response.end("<h1>Hello Vertx Application</h1>");
    });


    //start server
    server.listen(3001, serverHandler -> {
      if (serverHandler.succeeded()) {
        System.out.println("Http Server is up and running");
      } else {
        System.out.println(serverHandler.cause().getMessage());
      }
    });
  }
}
*********************************************************************************************
Configuration Object:
1.HttpServerConfiguration


package com.unisys.vertx.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class HttpServerOptionsApp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(HttpServerOptionsApp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();

    //HttpServer options
    HttpServerOptions options = new HttpServerOptions();
    options.setPort(3002);
    //create WebServer , Handle request  and Send Response

    HttpServer server = vertx.createHttpServer(options);

    //Handle Request
    server.requestHandler(context -> {
      //context is container object , having HttpResponse and HttpRequest.
      HttpServerResponse response = context.response();
      response.end("<h1>Hello Vertx Application</h1>");
    });


    //start server
    server.listen(serverHandler -> {
      if (serverHandler.succeeded()) {
        System.out.println("Http Server is up and running");
      } else {
        System.out.println(serverHandler.cause().getMessage());
      }
    });
  }
}
*******************************************************************************************

How to handle Client Request:
............................

package com.unisys.vertx.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class HttpClientRequestApp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(HttpClientRequestApp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();

    //HttpServer options
    HttpServerOptions options = new HttpServerOptions();
    options.setPort(3002);
    //create WebServer , Handle request  and Send Response

    HttpServer server = vertx.createHttpServer(options);

    //Handle Request
    server.requestHandler(context -> {

      //handle client request
      context.handler(chunk -> {
        System.out.println(chunk);
        context.response().end(chunk);
      });

    });


    //start server
    server.listen(serverHandler -> {
      if (serverHandler.succeeded()) {
        System.out.println("Http Server is up and running");
      } else {
        System.out.println(serverHandler.cause().getMessage());
      }
    });
  }
}
******************************************************************************************

Verticle Communication via HTTP 


Verticle 1(client) ----------------------Verticle 2(Server/Service)

package com.unisys.vertx.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.*;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class ServerVerticle extends AbstractVerticle {

  private void startApp() {
    //HttpServer options
    HttpServerOptions options = new HttpServerOptions();
    options.setPort(3001);
    //create WebServer , Handle request  and Send Response

    HttpServer server = vertx.createHttpServer(options);

    //Handle Request
    server.requestHandler(context -> {
      //context is container object , having HttpResponse and HttpRequest.
      HttpServerResponse response = context.response();
      response.putHeader("content-type", "application/json");
      JsonObject address = new JsonObject();
      address.put("city", "coimbatore").put("street", "10th street").put("state", "Tamil Nadu");
      JsonObject visitor = new JsonObject();
      visitor.put("name", "subramanian").put("address", address);
      //response.end("<h1>Hello Vertx Application</h1>");
      response.end(visitor.encodePrettily());
    });

    server.listen(serverHandler -> {
      if (serverHandler.succeeded()) {
        System.out.println("Http Server is up and running");
      } else {
        System.out.println(serverHandler.cause().getMessage());
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    startApp();
  }
}

class ClientVerticle extends AbstractVerticle {

  private void startRequest() {
    System.out.println("Client request");
    HttpClientOptions options = new HttpClientOptions();
    HttpClient client = vertx.createHttpClient(options);

    //talk to server
    client.request(HttpMethod.GET, 3001, "localhost", "/", res -> {
      System.out.println("Status : " + res.statusCode());
      //handle response /result
      res.bodyHandler(payload -> {
        System.out.println(payload);
      });
    }).end();

  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.setTimer(1000, ar -> {
      startRequest();
    });
  }
}


public class VerticleCommunicationViaHttp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(VerticleCommunicationViaHttp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new ServerVerticle());
    vertx.deployVerticle(new ClientVerticle());

  }
}
**********************************************************************************************

Task:
 Create two verticles
 1-Verticle who handles http communication
 2.Verticle who listnes message from the Verticle which has client message


  Client---send data-------|who reads data--->send data to another Verticle through Event Bus.

 
*********************************************************************************************

How to build non blocking RESTFull Web Services?

Resource based web Application , where data is returned in different format.

domain model

Methods URL Patterns

GET  /api/users/list
POST /api/users
GET  /api/users/1
PUT  /api/users/1

Can you build realtime REST Apps using core http module

 Yes,but very complex

Vertx Provides a module  - vertx-web

package com.unisys.vertx.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;


class HelloController extends AbstractVerticle {

  //router configuration
  public Router getHelloConfig() {
    //sub Routers
    Router router = Router.router(vertx);

    //end points
    router.get("/list").handler(ctx -> {
      ctx.response().end("Hello");
    });

    return router;
  }

  @Override
  public void start() throws Exception {
    super.start();
  }
}



class HaiController extends AbstractVerticle {

  //router configuration
  public Router getHaiConfig() {
    //sub Routers
    Router router = Router.router(vertx);
    //end points
    router.get("/list").handler(ctx -> {
      ctx.response().end("Hi ");
    });
    return router;
  }

  @Override
  public void start() throws Exception {
    super.start();
  }
}

//Front Controller
class AppController extends AbstractVerticle {

  HttpServer server;
  HttpServerOptions options;

  private void startApp() {
    options = new HttpServerOptions().setPort(3001).setHost("localhost");
    server = vertx.createHttpServer(options);
    //Routers : router
    Router appRouter = Router.router(vertx);
    //bind controlers with appRouter
    appRouter.mountSubRouter("/api/hello", new HelloController().getHelloConfig());
    appRouter.mountSubRouter("/api/hai", new HaiController().getHaiConfig());

    server.requestHandler(appRouter);

    //start
    server.listen(server -> {
      if (server.succeeded()) {
        System.out.println("REST Api Server is Ready!");
      }
    });
  }


  @Override
  public void start() throws Exception {
    super.start();
    startApp();
  }
}


public class RestApp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(RestApp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new AppController());
  }
}
********************************************************************************************

DataBase and Non Blocking:
..........................

package com.unisys.vertx.web.dataacces;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpHeaders;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.json.Json;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.mongo.MongoClient;
import io.vertx.ext.web.Router;


class HelloController extends AbstractVerticle {

  //router configuration
  public Router getHelloConfig() {
    //sub Routers
    Router router = Router.router(vertx);

    //end points
    router.get("/list").handler(ctx -> {
      ctx.response().end("Hello");
    });

    return router;
  }

  @Override
  public void start() throws Exception {
    super.start();
  }
}


class HaiController extends AbstractVerticle {

  //router configuration
  public Router getHaiConfig() {
    //sub Routers
    Router router = Router.router(vertx);
    //end points
    router.get("/list").handler(ctx -> {
      ctx.response().end("Hi ");
    });
    return router;
  }

  @Override
  public void start() throws Exception {
    super.start();
  }
}

//Book Repository
class BookRepository {
  MongoClient mongoClient;

  public BookRepository() {
  }

  public BookRepository(MongoClient mongoClient) {
    this.mongoClient = mongoClient;
  }

  //api talk to mongo and get data
  public Future<String> findAll() {
    Promise promise = Promise.promise();
    JsonObject query = new JsonObject();
    mongoClient.find("books", query, lookup -> {
      if (lookup.succeeded()) {
        //Store results in jsonArray
        JsonArray documents = new JsonArray();
        for (JsonObject document : lookup.result()) {
          documents.add(document);
        }
        promise.complete(documents.encodePrettily());

      } else {
        promise.fail(lookup.cause());
        return;
      }

    });


    return promise.future();
  }


}

///
class BooksController extends AbstractVerticle {
  private BookRepository bookRepository;

  public BooksController() {
  }

  public BooksController(MongoClient mongoClient) {
    bookRepository = new BookRepository(mongoClient);
  }

  //booksRouter
  public Router getBooksConfig() {
    //sub Routers
    Router router = Router.router(vertx);
    //end points
    router.get("/list").handler(ctx -> {

      //talk to book repo class to get records async, once the result is ready,send to client
      bookRepository.findAll().onComplete(ar -> {
        //verify result
        if (ar.succeeded()) {
          //set Header content type
          ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, "application/json");
          //flush the response
          ctx.response().end(ar.result());
        } else {
          ctx.response().end("Sorry Somthing went Wrong!!!!");
        }

      });


    });

    return router;
  }

}


//Front Controller
class AppController extends AbstractVerticle {

  HttpServer server;
  HttpServerOptions options;
  MongoClient mongoClient;

  private void startApp() {
    options = new HttpServerOptions().setPort(3001).setHost("localhost");
    server = vertx.createHttpServer(options);

    //connecting mongo db
    mongoClient = MongoClient.createShared(vertx, new JsonObject().put("db_name", "BooksDb"));
    BooksController booksController = new BooksController(mongoClient);
    //Routers : router
    Router appRouter = Router.router(vertx);
    //bind controlers with appRouter
    appRouter.mountSubRouter("/api/hello", new HelloController().getHelloConfig());
    appRouter.mountSubRouter("/api/hai", new HaiController().getHaiConfig());
    appRouter.mountSubRouter("/api/books", booksController.getBooksConfig());

    server.requestHandler(appRouter);

    //start
    server.listen(server -> {
      if (server.succeeded()) {
        System.out.println("REST Api Server is Ready!");
      }
    });
  }


  @Override
  public void start() throws Exception {
    super.start();
    startApp();
  }
}


public class RESTDataAccess extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(RESTDataAccess.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new AppController());
  }
}







